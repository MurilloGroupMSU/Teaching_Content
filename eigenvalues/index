<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eigenvalues of Correlation Matrix | MSU</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <style>
        :root {
            --msu-green: #18453B;
            --msu-light: #2D6154;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .title {
            color: var(--msu-green);
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .grid-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: var(--msu-green);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .button:hover {
            background: var(--msu-light);
        }

        .button.outline {
            background: white;
            color: var(--msu-green);
            border: 1px solid var(--msu-green);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider {
            width: 200px;
        }

        .matrix-cell {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 16px;
            background: white;
            color: var(--msu-green);
        }

        .panel {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .panel h3 {
            color: var(--msu-green);
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Eigenvalues and Eigenvectors of Correlation Matrix</h1>

        <div class="controls">
            <div class="slider-container">
                <button class="button outline" id="playPause">Play</button>
                <input type="range" class="slider" id="rotationSlider" min="0" max="360" value="0">
                <span id="angleDisplay">0°</span>
            </div>
            <button class="button outline" id="reset">Reset</button>
            <button class="button" id="generateNew">Generate New Data</button>
            <button class="button outline" id="toggleEigenvectors">Show Eigenvectors</button>
        </div>

        <div class="grid-display">
            <div class="panel">
                <h3>Data and Principal Directions</h3>
                <svg id="plot" width="300" height="300" viewBox="-120 -120 240 240">
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#eee" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    <rect x="-100" y="-100" width="200" height="200" fill="url(#grid)"/>
                    <line x1="-100" y1="0" x2="100" y2="0" stroke="#666" stroke-width="1"/>
                    <line x1="0" y1="-100" x2="0" y2="100" stroke="#666" stroke-width="1"/>
                    <text x="90" y="20" text-anchor="middle" fill="#666">X</text>
                    <text x="-20" y="-90" text-anchor="middle" fill="#666">Y</text>
                </svg>
            </div>

            <div class="panel">
                <h3>Correlation Matrix</h3>
                <div id="correlationMatrix" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px;"></div>
            </div>

            <div class="panel">
                <h3>Eigendecomposition</h3>
                <div id="eigenDisplay"></div>
                <svg id="eigenPlot" width="300" height="150">
                    <g id="eigenBars"></g>
                    <g id="eigenAxes"></g>
                </svg>
            </div>
        </div>
    </div>

    <script>
        let isPlaying = false;
        let angle = 0;
        let showEigenvectors = false;
        let animationId;

        // Generate correlated data
        function generateData() {
            const n = 100;
            const correlation = 0.8;
            const x = Array.from({length: n}, () => Math.random() * 2 - 1);
            const y = x.map(val => val * correlation + (Math.random() * 0.5 - 0.25));
            return [x, y];
        }

        let data = generateData();

        // Rotate point
        function rotatePoint(x, y, degrees) {
            const radians = degrees * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);
            return [
                x * cos - y * sin,
                x * sin + y * cos
            ];
        }

        // Rotate eigenvectors
        function rotateEigenvectors(vectors, degrees) {
            return vectors.map(vec => rotatePoint(vec[0], vec[1], degrees));
        }

        // Calculate correlation matrix
        function calculateCorrelationMatrix(x, y) {
            const meanX = x.reduce((a, b) => a + b, 0) / x.length;
            const meanY = y.reduce((a, b) => a + b, 0) / y.length;
            
            const centeredX = x.map(val => val - meanX);
            const centeredY = y.map(val => val - meanY);
            
            const stdX = Math.sqrt(centeredX.reduce((acc, val) => acc + val * val, 0) / (x.length - 1));
            const stdY = Math.sqrt(centeredY.reduce((acc, val) => acc + val * val, 0) / (y.length - 1));
            
            const correlation = centeredX.reduce((acc, val, i) => acc + val * centeredY[i], 0) / 
                              ((x.length - 1) * stdX * stdY);
            
            return [[1, correlation], [correlation, 1]];
        }

        // Draw vector
        function drawVector(svg, vector, scale, color = '#18453B') {
            const [x, y] = vector;
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", "0");
            line.setAttribute("y1", "0");
            line.setAttribute("x2", x * scale);
            line.setAttribute("y2", -y * scale);
            line.setAttribute("stroke", color);
            line.setAttribute("stroke-width", "2");
            line.setAttribute("stroke-dasharray", "4");
            svg.appendChild(line);
        }

        function updateVisualization() {
            // Clear previous visualization
            const svg = document.getElementById('plot');
            const points = svg.querySelectorAll('circle, line');
            points.forEach(point => point.remove());
            
            // Get original data and rotate it
            const [x, y] = data;
            const rotatedPoints = x.map((val, i) => rotatePoint(val, y[i], angle));
            const scale = 80;
            
            // Plot rotated data points
            rotatedPoints.forEach(([rx, ry]) => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", rx * scale);
                circle.setAttribute("cy", -ry * scale);
                circle.setAttribute("r", "3");
                circle.setAttribute("fill", "#18453B");
                circle.setAttribute("opacity", "0.5");
                svg.appendChild(circle);
            });

            // Calculate correlation matrix of rotated data
            const rotatedX = rotatedPoints.map(p => p[0]);
            const rotatedY = rotatedPoints.map(p => p[1]);
            const corrMatrix = calculateCorrelationMatrix(rotatedX, rotatedY);
            
            // Calculate eigendecomposition
            const eigen = math.eigs(corrMatrix);
            
            // Update correlation matrix display
            const matrixElement = document.getElementById('correlationMatrix');
            matrixElement.innerHTML = '';
            corrMatrix.flat().forEach(value => {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell';
                cell.textContent = value.toFixed(3);
                cell.style.backgroundColor = `rgba(24, 69, 59, ${Math.abs(value) * 0.5})`;
                cell.style.color = Math.abs(value) > 0.5 ? 'white' : 'black';
                matrixElement.appendChild(cell);
            });

            // Update eigenvalue display
            const eigenDisplay = document.getElementById('eigenDisplay');
            eigenDisplay.innerHTML = `
                <div style="margin: 10px 0;">
                    λ₁ = ${eigen.values[0].toFixed(3)}<br>
                    λ₂ = ${eigen.values[1].toFixed(3)}
                </div>
            `;

            // Draw eigenvectors if enabled
            if (showEigenvectors) {
                const rotatedEigenvectors = rotateEigenvectors(eigen.vectors, angle);
                rotatedEigenvectors.forEach((vec, i) => {
                    const magnitude = Math.sqrt(eigen.values[i]);
                    drawVector(svg, vec, scale * magnitude);
                    drawVector(svg, [-vec[0], -vec[1]], scale * magnitude);
                });
            }

            // Update eigenvalue bar plot
            const eigenPlot = document.getElementById('eigenBars');
            eigenPlot.innerHTML = '';
            const barScale = 100;
            eigen.values.forEach((val, i) => {
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", 50 + i * 100);
                rect.setAttribute("y", 150 - val * barScale);
                rect.setAttribute("width", "40");
                rect.setAttribute("height", val * barScale);
                rect.setAttribute("fill", "#18453B");
                rect.setAttribute("opacity", "0.7");
                eigenPlot.appendChild(rect);
            });
        }

        function animate() {
            if (isPlaying) {
                angle = (angle + 1) % 360;
                document.getElementById('rotationSlider').value = angle;
                document.getElementById('angleDisplay').textContent = `${angle}°`;
                updateVisualization();
                animationId = requestAnimationFrame(animate);
            }
        }

        // Event listeners
        document.getElementById('playPause').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playPause').textContent = isPlaying ? 'Pause' : 'Play';
            if (isPlaying) animate();
        });

        document.getElementById('reset').addEventListener('click', () => {
            angle = 0;
            document.getElementById('rotationSlider').value = 0;
            document.getElementById('angleDisplay').textContent = '0°';
            updateVisualization();
        });

        document.getElementById('generateNew').addEventListener('click', () => {
            data = generateData();
            updateVisualization();
        });

        document.getElementById('toggleEigenvectors').addEventListener('click', () => {
            showEigenvectors = !showEigenvectors;
            updateVisualization();
        });

        document.getElementById('rotationSlider').addEventListener('input', (e) => {
            isPlaying = false;
            document.getElementById('playPause').textContent = 'Play';
            angle = parseInt(e.target.value);
            document.getElementById('angleDisplay').textContent = `${angle}°`;
            updateVisualization();
        });

        // Initial setup
        updateVisualization();
    </script>
</body>
</html>
