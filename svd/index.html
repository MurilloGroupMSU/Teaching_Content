<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singular Value Decomposition | MSU</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <style>
        :root {
            --msu-green: #18453B;
            --msu-light: #2D6154;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .title {
            color: var(--msu-green);
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .grid-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: var(--msu-green);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .button:hover {
            background: var(--msu-light);
        }

        .button.outline {
            background: white;
            color: var(--msu-green);
            border: 1px solid var(--msu-green);
        }

        .panel {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .panel h3 {
            color: var(--msu-green);
            margin-top: 0;
        }

        .step-panel {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .step-description {
            font-size: 1.1em;
            line-height: 1.6;
            margin: 10px 0;
            color: var(--msu-green);
        }

        .equation {
            font-family: 'Computer Modern', serif;
            font-size: 1.2em;
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }

        .matrix-display {
            display: grid;
            grid-template-columns: repeat(3, auto);
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        .matrix {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }

        .matrix-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 14px;
            background: #f8f9fa;
        }

        .operator {
            font-size: 24px;
            color: var(--msu-green);
        }

        .progress-dots {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
        }

        .dot.active {
            background: var(--msu-green);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Singular Value Decomposition (SVD)</h1>

        <div class="controls">
            <button class="button outline" id="prevStep">Previous</button>
            <button class="button outline" id="nextStep">Next</button>
            <button class="button" id="generateNew">Generate New Data</button>
            <button class="button outline" id="playPause">Play Animation</button>
        </div>

        <div class="step-panel">
            <div class="progress-dots">
                <div class="dot active"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div class="step-description" id="stepDescription"></div>
            <div class="equation" id="stepEquation"></div>
        </div>

        <div class="grid-display">
            <div class="panel">
                <h3>Original Space</h3>
                <svg id="originalPlot" width="300" height="300" viewBox="-120 -120 240 240" style="border: 1px solid #ccc;">
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#eee" stroke-width="0.5"/>
                        </pattern>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#18453B"/>
                        </marker>
                    </defs>
                    <rect x="-100" y="-100" width="200" height="200" fill="url(#grid)"/>
                    <line x1="-100" y1="0" x2="100" y2="0" stroke="#666" stroke-width="1"/>
                    <line x1="0" y1="-100" x2="0" y2="100" stroke="#666" stroke-width="1"/>
                </svg>
            </div>

            <div class="panel">
                <h3>Matrix Decomposition</h3>
                <div id="matrixDisplay" class="matrix-display"></div>
            </div>

            <div class="panel">
                <h3>Transformed Space</h3>
                <svg id="transformedPlot" width="300" height="300" viewBox="-120 -120 240 240" style="border: 1px solid #ccc;">
                    <defs>
                        <pattern id="grid2" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#eee" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    <rect x="-100" y="-100" width="200" height="200" fill="url(#grid2)"/>
                    <line x1="-100" y1="0" x2="100" y2="0" stroke="#666" stroke-width="1"/>
                    <line x1="0" y1="-100" x2="0" y2="100" stroke="#666" stroke-width="1"/>
                </svg>
            </div>
        </div>
    </div>
    <circle cx="0" cy="0" r="5" fill="red"/>
    <script>
                // Test math.js loading
        console.log('Math.js version:', math ? math.version : 'not loaded');

        // Test SVD functionality
        try {
            const testMatrix = [[1, 2], [3, 4]];
            const testSVD = math.svd(testMatrix);
            console.log('Test SVD works:', testSVD);
        } catch (error) {
            console.error('SVD test failed:', error);
        }
        let currentStep = 0;
        let isPlaying = false;
        let animationId;
        let transitionProgress = 0;
        
        // Generate correlated data
        function generateData() {
            const n = 100;
            const correlation = 0.8;
            const x = Array.from({length: n}, () => Math.random() * 2 - 1);
            const y = x.map(val => val * correlation + (Math.random() * 0.5 - 0.25));
            console.log('Generated data - x:', x.slice(0,5), 'y:', y.slice(0,5)); // Show first 5 points
            return [x, y];
        }

        let data = generateData();
        let svd = null;

        const steps = [
            {
                id: 'original',
                description: 'Start with our original data matrix X',
                equation: 'X = [x₁ x₂ ... xₙ]^T'
            },
            {
                id: 'rotation',
                description: 'V^T rotates the data to align with principal directions',
                equation: 'First rotate by V^T'
            },
            {
                id: 'scaling',
                description: 'Σ scales the data along each direction',
                equation: 'Then scale by Σ = diag(σ₁, σ₂)'
            },
            {
                id: 'coordinates',
                description: 'U gives the final coordinates in the new basis',
                equation: 'X = UΣV^T'
            }
        ];

        function calculateSVD() {
    console.log('Calculating SVD...');
    console.log('Initial data:', data);
    
    const X = [];
    for (let i = 0; i < data[0].length; i++) {
        X.push([data[0][i], data[1][i]]);
    }
    console.log('Matrix X:', X);
    
    svd = math.svd(X);
    console.log('SVD result:', svd);
    
    // Verify SVD components
    console.log('U:', svd.U);
    console.log('S:', svd.S);
    console.log('V:', svd.V);
}

        function drawPoint(svg, x, y, color = '#18453B', opacity = 0.5) {
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x * 80);
            circle.setAttribute("cy", -y * 80);
            circle.setAttribute("r", "3");
            circle.setAttribute("fill", color);
            circle.setAttribute("opacity", opacity);
            svg.appendChild(circle);
        }

        function drawVector(svg, vec, color = '#18453B', opacity = 0.7) {
            const [x, y] = vec;
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", "0");
            line.setAttribute("y1", "0");
            line.setAttribute("x2", x * 80);
            line.setAttribute("y2", -y * 80);
            line.setAttribute("stroke", color);
            line.setAttribute("stroke-width", "2");
            line.setAttribute("marker-end", "url(#arrowhead)");
            line.setAttribute("opacity", opacity);
            svg.appendChild(line);
        }

        function updateVisualization() {
            // Update progress dots
            document.querySelectorAll('.dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === currentStep);
            });

            // Update step description and equation
            document.getElementById('stepDescription').textContent = steps[currentStep].description;
            document.getElementById('stepEquation').textContent = steps[currentStep].equation;

            // Clear previous plots
            const originalPlot = document.getElementById('originalPlot');
            const transformedPlot = document.getElementById('transformedPlot');
            ['circle', 'line'].forEach(tag => {
                originalPlot.querySelectorAll(tag).forEach(el => el.remove());
                transformedPlot.querySelectorAll(tag).forEach(el => el.remove());
            });

            if (!svd) calculateSVD();

            // Draw based on current step
            switch(currentStep) {
                case 0: // Original data
                    data[0].forEach((x, i) => drawPoint(originalPlot, x, data[1][i]));
                    break;
                    
                case 1: // V^T rotation
                    // Draw original data faded
                    data[0].forEach((x, i) => drawPoint(originalPlot, x, data[1][i], '#999', 0.2));
                    
                    // Draw rotated data
                    const rotated = math.multiply(data[0].map((x, i) => [x, data[1][i]]), svd.V);
                    rotated.forEach(point => drawPoint(transformedPlot, point[0], point[1]));
                    
                    // Draw principal directions
                    drawVector(originalPlot, [svd.V[0][0], svd.V[1][0]], '#e63946');
                    drawVector(originalPlot, [svd.V[0][1], svd.V[1][1]], '#457b9d');
                    break;
                    
                case 2: // Σ scaling
                    rotated = math.multiply(data[0].map((x, i) => [x, data[1][i]]), svd.V);
                    rotated.forEach(point => drawPoint(transformedPlot, point[0], point[1], '#999', 0.2));
                    
                    // Draw scaled data
                    const scaled = rotated.map(point => [
                        point[0] * svd.S[0],
                        point[1] * svd.S[1]
                    ]);
                    scaled.forEach(point => drawPoint(transformedPlot, point[0], point[1]));
                    break;
                    
                case 3: // Final transformation
                    const final = math.multiply(data[0].map((x, i) => [x, data[1][i]]), svd.V);
                    final.forEach(point => {
                        const scaled = [point[0] * svd.S[0], point[1] * svd.S[1]];
                        drawPoint(transformedPlot, scaled[0], scaled[1]);
                    });
                    break;
            }

            // Update matrix display
            updateMatrixDisplay();
        }

        function updateMatrixDisplay() {
            const display = document.getElementById('matrixDisplay');
            display.innerHTML = '';

            // Format matrices for display based on current step
            // This could be enhanced with actual values and proper formatting
            switch(currentStep) {
                case 0:
                    display.innerHTML = `
                        <div class="matrix">X</div>
                    `;
                    break;
                case 1:
                    display.innerHTML = `
                        <div class="matrix">X</div>
                        <div class="operator">=</div>
                        <div class="matrix">V^T</div>
                    `;
                    break;
                case 2:
                    display.innerHTML = `
                        <div class="matrix">X</div>
                        <div class="operator">=</div>
                        <div class="matrix">ΣV^T</div>
                    `;
                    break;
                case 3:
                    display.innerHTML = `
                        <div class="matrix">X</div>
                        <div class="operator">=</div>
                        <div class="matrix">UΣV^T</div>
                    `;
                    break;
            }
        }

        function animate() {
            if (isPlaying) {
                transitionProgress += 0.02;
                if (transitionProgress >= 1) {
                    transitionProgress = 0;
                    isPlaying = false;
                    if (currentStep < steps.length - 1) {
                        currentStep++;
                        updateVisualization();
                    }
                } else {
                    // Smooth transition between steps
                    updateTransitionState(transitionProgress);
                }
                requestAnimationFrame(animate);
            }
        }

        function updateTransitionState(progress) {
            const originalPlot = document.getElementById('originalPlot');
            const transformedPlot = document.getElementById('transformedPlot');
            ['circle', 'line'].forEach(tag => {
                originalPlot.querySelectorAll(tag).forEach(el => el.remove());
                transformedPlot.querySelectorAll(tag).forEach(el => el.remove());
            });

            if (!svd) calculateSVD();

            switch(currentStep) {
                case 0:
                    // Static display of original data
                    data[0].forEach((x, i) => drawPoint(originalPlot, x, data[1][i]));
                    break;

                case 1:
                    // Animate rotation by V^T
                    const angle = progress * Math.PI / 2;
                    const rotationMatrix = [
                        [Math.cos(angle), -Math.sin(angle)],
                        [Math.sin(angle), Math.cos(angle)]
                    ];
                    
                    // Draw faded original data
                    data[0].forEach((x, i) => drawPoint(originalPlot, x, data[1][i], '#999', 0.2));
                    
                    // Draw rotating data
                    const rotatingData = data[0].map((x, i) => {
                        const point = [x, data[1][i]];
                        const rotated = math.multiply(point, rotationMatrix);
                        return rotated;
                    });
                    
                    rotatingData.forEach(point => drawPoint(transformedPlot, point[0], point[1]));
                    
                    // Draw rotating principal directions
                    const v1 = math.multiply([svd.V[0][0], svd.V[1][0]], rotationMatrix);
                    const v2 = math.multiply([svd.V[0][1], svd.V[1][1]], rotationMatrix);
                    drawVector(transformedPlot, v1, '#e63946');
                    drawVector(transformedPlot, v2, '#457b9d');
                    break;

                case 2:
                    // Animate scaling by Σ
                    const scale1 = 1 + (svd.S[0] - 1) * progress;
                    const scale2 = 1 + (svd.S[1] - 1) * progress;
                    
                    const rotated = math.multiply(data[0].map((x, i) => [x, data[1][i]]), svd.V);
                    rotated.forEach(point => drawPoint(transformedPlot, point[0], point[1], '#999', 0.2));
                    
                    const scaledData = rotated.map(point => [
                        point[0] * scale1,
                        point[1] * scale2
                    ]);
                    
                    scaledData.forEach(point => drawPoint(transformedPlot, point[0], point[1]));
                    break;

                case 3:
                    // Show final transformation
                    const final = math.multiply(data[0].map((x, i) => [x, data[1][i]]), svd.V);
                    final.forEach(point => {
                        const scaled = [point[0] * svd.S[0], point[1] * svd.S[1]];
                        drawPoint(transformedPlot, scaled[0], scaled[1]);
                    });
                    break;
            }
        }

        // Event listeners
        document.getElementById('prevStep').addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                transitionProgress = 0;
                updateVisualization();
            }
        });

        document.getElementById('nextStep').addEventListener('click', () => {
            if (currentStep < steps.length - 1) {
                currentStep++;
                transitionProgress = 0;
                updateVisualization();
            }
        });

        document.getElementById('generateNew').addEventListener('click', () => {
            data = generateData();
            svd = null;
            currentStep = 0;
            transitionProgress = 0;
            updateVisualization();
        });

        document.getElementById('playPause').addEventListener('click', () => {
            const button = document.getElementById('playPause');
            isPlaying = !isPlaying;
            button.textContent = isPlaying ? 'Pause Animation' : 'Play Animation';
            if (isPlaying) {
                transitionProgress = 0;
                animate();
            }
        });

        // Initialize visualization
        updateVisualization();
    </script>
</body>
</html>
